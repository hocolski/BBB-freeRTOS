//####################################################
//AM3358_SK GEL file
//v1.1 Apr3,2012 Fixed WDT1 disable
//v1.1 May2,2012 Streamlined DDR3 PHY configuration routines, 
//               included proper DDR3 PHY values
//v1.2 Jun18,2012 
//####################################################


//****************************************************
//PRCM module definitions
//****************************************************
#define PRCM_BASE_ADDR                    (0x44E00000)
#define CM_PER_EMIF_CLKCTRL               (PRCM_BASE_ADDR + 0x028)
#define CM_PER_EMIF_FW_CLKCTRL            (PRCM_BASE_ADDR + 0x0D0)

#define	SOC_CM_PER_REGS					  (PRCM_BASE_ADDR + 0x0)
#define	SOC_CM_WKUP_REGS				  (PRCM_BASE_ADDR + 0x400)

#define CM_PER_L3_CLKCTRL 				  (SOC_CM_PER_REGS + 0x0E0)
#define CM_PER_L3_INSTR_CLKCTRL			  (SOC_CM_PER_REGS + 0x0DC)
#define	CM_PER_L3_CLKSTCTRL				  (SOC_CM_PER_REGS + 0x00C)
#define	CM_PER_OCPWP_L3_CLKSTCTRL		  (SOC_CM_PER_REGS + 0x12c)
#define	CM_PER_L3S_CLKSTCTRL			  (SOC_CM_PER_REGS + 0x004)

#define	CM_WKUP_CLKSTCTRL				  (SOC_CM_WKUP_REGS + 0x0)
#define	CM_WKUP_CONTROL_CLKCTRL			  (SOC_CM_WKUP_REGS + 0x4)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL 	  (SOC_CM_WKUP_REGS + 0x18)
#define CM_WKUP_GPIO0_CLKCTRL 			  (SOC_CM_WKUP_REGS + 0x8)
#define CM_WKUP_L4WKUP_CLKCTRL 		      (SOC_CM_WKUP_REGS + 0xc)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL  (SOC_CM_WKUP_REGS + 0xcc)

#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_DISABLED   (0x0u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)

/* CLKSTCTRL */
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_ADC_FCLK   (0x00004000u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_ADC_FCLK_SHIFT   (0x0000000Eu)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_ADC_FCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_ADC_FCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_GPIO0_GDBCLK   (0x00000100u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_GPIO0_GDBCLK_SHIFT   (0x00000008u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_GPIO0_GDBCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_GPIO0_GDBCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_I2C0_GFCLK   (0x00000800u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_I2C0_GFCLK_SHIFT   (0x0000000Bu)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_I2C0_GFCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_I2C0_GFCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK   (0x00000004u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK_SHIFT   (0x00000002u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_SR_SYSCLK   (0x00000008u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_SR_SYSCLK_SHIFT   (0x00000003u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_SR_SYSCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_SR_SYSCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER0_GCLK   (0x00000400u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER0_GCLK_SHIFT   (0x0000000Au)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER0_GCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER0_GCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER1_GCLK   (0x00002000u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER1_GCLK_SHIFT   (0x0000000Du)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER1_GCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_TIMER1_GCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK   (0x00001000u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK_SHIFT   (0x0000000Cu)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_UART0_GFCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT0_GCLK   (0x00000200u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT0_GCLK_SHIFT   (0x00000009u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT0_GCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT0_GCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT1_GCLK   (0x00000010u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT1_GCLK_SHIFT   (0x00000004u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT1_GCLK_ACT   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKACTIVITY_WDT1_GCLK_INACT   (0x0u)

#define CM_WKUP_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_WKUP_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_WKUP_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_WKUP_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)

/* CONTROL_CLKCTRL */
#define CM_WKUP_CONTROL_CLKCTRL_IDLEST   (0x00030000u)
#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_DISABLE   (0x3u)
#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_FUNC   (0x0u)
#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_IDLE   (0x2u)
#define CM_WKUP_CONTROL_CLKCTRL_IDLEST_TRANS   (0x1u)

#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_DISABLED   (0x0u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
#define CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)

/* GPIO0_CLKCTRL */
#define CM_WKUP_GPIO0_CLKCTRL_IDLEST   (0x00030000u)
#define CM_WKUP_GPIO0_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
#define CM_WKUP_GPIO0_CLKCTRL_IDLEST_DISABLED   (0x3u)
#define CM_WKUP_GPIO0_CLKCTRL_IDLEST_FUNC   (0x0u)
#define CM_WKUP_GPIO0_CLKCTRL_IDLEST_IDLE   (0x2u)
#define CM_WKUP_GPIO0_CLKCTRL_IDLEST_TRANS   (0x1u)

#define CM_WKUP_GPIO0_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_DISABLE   (0x0u)
#define CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
#define CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)

#define CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK   (0x00040000u)
#define CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK_SHIFT   (0x00000012u)
#define CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK_FCLK_DIS   (0x0u)
#define CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK_FCLK_EN   (0x1u)

/* CM_L3_AON_CLKSTCTRL */
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_DBGSYSCLK   (0x00000004u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_DBGSYSCLK_SHIFT   (0x00000002u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_DBGSYSCLK_ACT   (0x1u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_DBGSYSCLK_INACT   (0x0u)

#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_DEBUG_CLKA   (0x00000010u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_DEBUG_CLKA_SHIFT   (0x00000004u)

#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK   (0x00000008u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK_SHIFT   (0x00000003u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK_ACT   (0x1u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK_INACT   (0x0u)

#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)

/* L4WKUP_CLKCTRL */
#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST   (0x00030000u)
#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_DISABLE   (0x3u)
#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_FUNC   (0x0u)
#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_IDLE   (0x2u)
#define CM_WKUP_L4WKUP_CLKCTRL_IDLEST_TRANS   (0x1u)

#define CM_WKUP_L4WKUP_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_WKUP_L4WKUP_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_WKUP_L4WKUP_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_WKUP_L4WKUP_CLKCTRL_MODULEMODE_DISABLE  (0x0u)

/* CM_L4_WKUP_AON_CLKSTCTRL */
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK   (0x00000004u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK_SHIFT   (0x00000002u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK_ACT   (0x1u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK_INACT   (0x0u)

#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP    (0x2u)
#define CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKTRCTRL_HW_AUTO    (0x3u)



/* L3_INSTR_CLKCTRL */
#define CM_PER_L3_INSTR_CLKCTRL_IDLEST   (0x00030000u)
#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_DISABLE   (0x3u)
#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_FUNC   (0x0u)
#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_IDLE   (0x2u)
#define CM_PER_L3_INSTR_CLKCTRL_IDLEST_TRANS   (0x1u)

#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_DISABLED   (0x0u)
#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
#define CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)


/* L3_CLKCTRL */
#define CM_PER_L3_CLKCTRL_IDLEST   (0x00030000u)
#define CM_PER_L3_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
#define CM_PER_L3_CLKCTRL_IDLEST_DISABLE   (0x3u)
#define CM_PER_L3_CLKCTRL_IDLEST_FUNC   (0x0u)
#define CM_PER_L3_CLKCTRL_IDLEST_IDLE   (0x2u)
#define CM_PER_L3_CLKCTRL_IDLEST_TRANS   (0x1u)

#define CM_PER_L3_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_PER_L3_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_PER_L3_CLKCTRL_MODULEMODE_DISABLED   (0x0u)
#define CM_PER_L3_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_PER_L3_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
#define CM_PER_L3_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)

/* L4LS_CLKSTCTRL */
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_CAN_CLK   (0x00000800u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_CAN_CLK_SHIFT   (0x0000000Bu)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_CAN_CLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_CAN_CLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_1_GDBCLK   (0x00080000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_1_GDBCLK_SHIFT   (0x00000013u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_1_GDBCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_1_GDBCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_2_GDBCLK   (0x00100000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_2_GDBCLK_SHIFT   (0x00000014u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_2_GDBCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_2_GDBCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_3_GDBCLK   (0x00200000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_3_GDBCLK_SHIFT   (0x00000015u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_3_GDBCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_GPIO_3_GDBCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_I2C_FCLK   (0x01000000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_I2C_FCLK_SHIFT   (0x00000018u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_I2C_FCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_I2C_FCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK   (0x00000100u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK_SHIFT   (0x00000008u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_L4LS_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_LCDC_GCLK   (0x00020000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_LCDC_GCLK_SHIFT   (0x00000011u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_LCDC_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_LCDC_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_SPI_GCLK   (0x02000000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_SPI_GCLK_SHIFT   (0x00000019u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_SPI_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_SPI_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER2_GCLK   (0x00004000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER2_GCLK_SHIFT   (0x0000000Eu)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER2_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER2_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER3_GCLK   (0x00008000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER3_GCLK_SHIFT   (0x0000000Fu)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER3_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER3_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER4_GCLK   (0x00010000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER4_GCLK_SHIFT   (0x00000010u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER4_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER4_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER5_GCLK   (0x08000000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER5_GCLK_SHIFT   (0x0000001Bu)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER5_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER5_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER6_GCLK   (0x10000000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER6_GCLK_SHIFT   (0x0000001Cu)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER6_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER6_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK   (0x00002000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK_SHIFT   (0x0000000Du)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_TIMER7_GCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_UART_GFCLK   (0x00000400u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_UART_GFCLK_SHIFT   (0x0000000Au)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_UART_GFCLK_ACT   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKACTIVITY_UART_GFCLK_INACT   (0x0u)

#define CM_PER_L4LS_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_PER_L4LS_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_PER_L4LS_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_PER_L4LS_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_PER_L4LS_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_PER_L4LS_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)


/* L3S_CLKSTCTRL */
#define CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK   (0x00000008u)
#define CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK_SHIFT   (0x00000003u)
#define CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK_ACT   (0x1u)
#define CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK_INACT   (0x0u)

#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)


/* L4FW_CLKSTCTRL */
#define CM_PER_L4FW_CLKSTCTRL_CLKACTIVITY_L4FW_GCLK   (0x00000100u)
#define CM_PER_L4FW_CLKSTCTRL_CLKACTIVITY_L4FW_GCLK_SHIFT   (0x00000008u)
#define CM_PER_L4FW_CLKSTCTRL_CLKACTIVITY_L4FW_GCLK_ACT   (0x1u)
#define CM_PER_L4FW_CLKSTCTRL_CLKACTIVITY_L4FW_GCLK_INACT   (0x0u)

#define CM_PER_L4FW_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_PER_L4FW_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_PER_L4FW_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_PER_L4FW_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_PER_L4FW_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_PER_L4FW_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)


/* L3_CLKSTCTRL */
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_CPTS_RFT_GCLK   (0x00000040u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_CPTS_RFT_GCLK_SHIFT   (0x00000006u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_CPTS_RFT_GCLK_ACT   (0x1u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_CPTS_RFT_GCLK_INACT   (0x0u)

#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_EMIF_GCLK   (0x00000004u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_EMIF_GCLK_SHIFT   (0x00000002u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_EMIF_GCLK_ACT   (0x1u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_EMIF_GCLK_INACT   (0x0u)

#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK   (0x00000010u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK_SHIFT   (0x00000004u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK_ACT   (0x1u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK_INACT   (0x0u)

#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MCASP_GCLK   (0x00000080u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MCASP_GCLK_SHIFT   (0x00000007u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MCASP_GCLK_ACT   (0x1u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MCASP_GCLK_INACT   (0x0u)

#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MMC_FCLK   (0x00000008u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MMC_FCLK_SHIFT   (0x00000003u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MMC_FCLK_ACT   (0x1u)
#define CM_PER_L3_CLKSTCTRL_CLKACTIVITY_MMC_FCLK_INACT   (0x0u)

#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)

/* OCPWP_L3_CLKSTCTRL */
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK   (0x00000010u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK_SHIFT   (0x00000004u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK_ACT   (0x1u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK_INACT   (0x0u)

#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK   (0x00000020u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK_SHIFT   (0x00000005u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK_ACT   (0x1u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L4_GCLK_INACT   (0x0u)

#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL   (0x00000003u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SHIFT   (0x00000000u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_HW_AUTO   (0x3u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_NO_SLEEP   (0x0u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_SLEEP   (0x1u)
#define CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP   (0x2u)


/* OCPWP_CLKCTRL */
#define CM_PER_OCPWP_CLKCTRL_IDLEST   (0x00030000u)
#define CM_PER_OCPWP_CLKCTRL_IDLEST_SHIFT   (0x00000010u)
#define CM_PER_OCPWP_CLKCTRL_IDLEST_DISABLE   (0x3u)
#define CM_PER_OCPWP_CLKCTRL_IDLEST_FUNC   (0x0u)
#define CM_PER_OCPWP_CLKCTRL_IDLEST_IDLE   (0x2u)
#define CM_PER_OCPWP_CLKCTRL_IDLEST_TRANS   (0x1u)

#define CM_PER_OCPWP_CLKCTRL_MODULEMODE   (0x00000003u)
#define CM_PER_OCPWP_CLKCTRL_MODULEMODE_SHIFT   (0x00000000u)
#define CM_PER_OCPWP_CLKCTRL_MODULEMODE_DISABLED   (0x0u)
#define CM_PER_OCPWP_CLKCTRL_MODULEMODE_ENABLE   (0x2u)
#define CM_PER_OCPWP_CLKCTRL_MODULEMODE_RESERVED   (0x3u)
#define CM_PER_OCPWP_CLKCTRL_MODULEMODE_RESERVED_1   (0x1u)

#define CM_PER_OCPWP_CLKCTRL_STBYST   (0x00040000u)
#define CM_PER_OCPWP_CLKCTRL_STBYST_SHIFT   (0x00000012u)
#define CM_PER_OCPWP_CLKCTRL_STBYST_FUNC   (0x0u)
#define CM_PER_OCPWP_CLKCTRL_STBYST_STANDBY   (0x1u)



#define CM_AUTOIDLE_DPLL_MPU              (PRCM_BASE_ADDR + 0x41C)
#define CM_IDLEST_DPLL_MPU                (PRCM_BASE_ADDR + 0x420)
#define CM_CLKSEL_DPLL_MPU                (PRCM_BASE_ADDR + 0x42C)
#define CM_AUTOIDLE_DPLL_DDR              (PRCM_BASE_ADDR + 0x430)
#define CM_IDLEST_DPLL_DDR                (PRCM_BASE_ADDR + 0x434)
#define CM_CLKSEL_DPLL_DDR                (PRCM_BASE_ADDR + 0x440)
#define CM_AUTOIDLE_DPLL_DISP             (PRCM_BASE_ADDR + 0x444)
#define CM_IDLEST_DPLL_DISP               (PRCM_BASE_ADDR + 0x448)
#define CM_CLKSEL_DPLL_DISP               (PRCM_BASE_ADDR + 0x454)
#define CM_AUTOIDLE_DPLL_CORE             (PRCM_BASE_ADDR + 0x458)
#define CM_IDLEST_DPLL_CORE               (PRCM_BASE_ADDR + 0x45C)
#define CM_CLKSEL_DPLL_CORE               (PRCM_BASE_ADDR + 0x468)
#define CM_AUTOIDLE_DPLL_PER              (PRCM_BASE_ADDR + 0x46C)
#define CM_IDLEST_DPLL_PER                (PRCM_BASE_ADDR + 0x470)
#define CM_CLKSEL_DPLL_PER                (PRCM_BASE_ADDR + 0x49C)

#define CM_DIV_M4_DPLL_CORE               (PRCM_BASE_ADDR + 0x480)
#define CM_DIV_M5_DPLL_CORE               (PRCM_BASE_ADDR + 0x484)
#define CM_CLKMODE_DPLL_MPU               (PRCM_BASE_ADDR + 0x488)
#define CM_CLKMODE_DPLL_PER               (PRCM_BASE_ADDR + 0x48C)
#define CM_CLKMODE_DPLL_CORE              (PRCM_BASE_ADDR + 0x490)
#define CM_CLKMODE_DPLL_DDR               (PRCM_BASE_ADDR + 0x494)
#define CM_CLKMODE_DPLL_DISP              (PRCM_BASE_ADDR + 0x498)

#define CM_DIV_M2_DPLL_DDR                (PRCM_BASE_ADDR + 0x4A0)
#define CM_DIV_M2_DPLL_DISP               (PRCM_BASE_ADDR + 0x4A4)
#define CM_DIV_M2_DPLL_MPU                (PRCM_BASE_ADDR + 0x4A8)
#define CM_DIV_M2_DPLL_PER                (PRCM_BASE_ADDR + 0x4AC)
#define CM_DIV_M6_DPLL_CORE               (PRCM_BASE_ADDR + 0x4D8)

#define CM_CLKOUT_CTRL                    (PRCM_BASE_ADDR + 0x700)

//****************************************************
//Control module definitions
//****************************************************

#define CONTROL_BASE_ADDR       (0x44E10000)

#define CONTROL_STATUS          (CONTROL_BASE_ADDR + 0x40)
#define CONF_XDMA_EVENT_INTR1   (CONTROL_BASE_ADDR + 0x9b4)

#define CONTROL_CONF_ECAP0_IN_PWM0_OUT	(CONTROL_BASE_ADDR + 0x964)
#define CONTROL_CONF_GPIO0_7	0x00000067 //RXACTIVE, GPIO Pin number =7, Pullup enabled, Pulldown selected, pulldown enabled


//****************************************************
//GPIO module definitions
//****************************************************

#define SOC_GPIO_0_REGS				(0x44E07000)
#define GPIO_CTRL 					(0x130)
#define	GPIO_OE						(0x134)
#define GPIO_SYSCONFIG 				(0x10)
#define GPIO_SYSSTATUS 				(0x114)
#define GPIO_SETDATAOUT				(0x194)


#define	GPIO_CTRL_DISABLEMODULE		(0x00000001)
#define	GPIO_SYSCONFIG_SOFTRESET	(0x00000002)
#define	GPIO_SYSSTATUS_RESETDONE	(0x00000001)

//DDR IO Control Registers
#define DDR_IO_CTRL             (CONTROL_BASE_ADDR + 0x0E04) 
#define VTP_CTRL_REG            (CONTROL_BASE_ADDR + 0x0E0C) 
#define DDR_CKE_CTRL            (CONTROL_BASE_ADDR + 0x131C)
#define DDR_CMD0_IOCTRL         (CONTROL_BASE_ADDR + 0x1404)
#define DDR_CMD1_IOCTRL         (CONTROL_BASE_ADDR + 0x1408)
#define DDR_CMD2_IOCTRL         (CONTROL_BASE_ADDR + 0x140C)
#define DDR_DATA0_IOCTRL        (CONTROL_BASE_ADDR + 0x1440)
#define DDR_DATA1_IOCTRL        (CONTROL_BASE_ADDR + 0x1444)

//********************************************************************
//EMIF4DC module definitions
//********************************************************************
#define EMIF_BASE_ADDR                    (0x4C000000)
#define EMIF_STATUS_REG                   (EMIF_BASE_ADDR + 0x004)
#define EMIF_SDRAM_CONFIG_REG             (EMIF_BASE_ADDR + 0x008)
#define EMIF_SDRAM_CONFIG_2_REG           (EMIF_BASE_ADDR + 0x00C)
#define EMIF_SDRAM_REF_CTRL_REG           (EMIF_BASE_ADDR + 0x010)
#define EMIF_SDRAM_REF_CTRL_SHDW_REG      (EMIF_BASE_ADDR + 0x014)
#define EMIF_SDRAM_TIM_1_REG              (EMIF_BASE_ADDR + 0x018)
#define EMIF_SDRAM_TIM_1_SHDW_REG         (EMIF_BASE_ADDR + 0x01C)
#define EMIF_SDRAM_TIM_2_REG              (EMIF_BASE_ADDR + 0x020)
#define EMIF_SDRAM_TIM_2_SHDW_REG         (EMIF_BASE_ADDR + 0x024)
#define EMIF_SDRAM_TIM_3_REG              (EMIF_BASE_ADDR + 0x028)
#define EMIF_SDRAM_TIM_3_SHDW_REG         (EMIF_BASE_ADDR + 0x02C)
#define EMIF_LPDDR2_NVM_TIM_REG           (EMIF_BASE_ADDR + 0x030)
#define EMIF_LPDDR2_NVM_TIM_SHDW_REG      (EMIF_BASE_ADDR + 0x034)
#define EMIF_PWR_MGMT_CTRL_REG            (EMIF_BASE_ADDR + 0x038)
#define EMIF_PWR_MGMT_CTRL_SHDW_REG       (EMIF_BASE_ADDR + 0x03C)
#define EMIF_LPDDR2_MODE_REG_DATA_REG     (EMIF_BASE_ADDR + 0x040)
#define EMIF_LPDDR2_MODE_REG_CFG_REG      (EMIF_BASE_ADDR + 0x050)
#define EMIF_OCP_CONFIG_REG               (EMIF_BASE_ADDR + 0x054)
#define EMIF_OCP_CFG_VAL_1_REG            (EMIF_BASE_ADDR + 0x058)
#define EMIF_OCP_CFG_VAL_2_REG            (EMIF_BASE_ADDR + 0x05C)
#define EMIF_IODFT_TLGC_REG               (EMIF_BASE_ADDR + 0x060)
#define EMIF_IODFT_CTRL_MISR_RSLT_REG     (EMIF_BASE_ADDR + 0x064)
#define EMIF_IODFT_ADDR_MISR_RSLT_REG     (EMIF_BASE_ADDR + 0x068)
#define EMIF_IODFT_DATA_MISR_RSLT_1_REG   (EMIF_BASE_ADDR + 0x06C)
#define EMIF_IODFT_DATA_MISR_RSLT_2_REG   (EMIF_BASE_ADDR + 0x070)
#define EMIF_IODFT_DATA_MISR_RSLT_3_REG   (EMIF_BASE_ADDR + 0x074)
#define EMIF_PERF_CNT_1_REG               (EMIF_BASE_ADDR + 0x080)
#define EMIF_PERF_CNT_2_REG               (EMIF_BASE_ADDR + 0x084)
#define EMIF_PERF_CNT_CFG_REG             (EMIF_BASE_ADDR + 0x088)
#define EMIF_PERF_CNT_SEL_REG             (EMIF_BASE_ADDR + 0x08C)
#define EMIF_PERF_CNT_TIM_REG             (EMIF_BASE_ADDR + 0x090)
#define EMIF_READ_IDLE_CTRL_REG           (EMIF_BASE_ADDR + 0x098)
#define EMIF_READ_IDLE_CTRL_SHDW_REG      (EMIF_BASE_ADDR + 0x09C)
#define EMIF_IRQ_EOI_REG                  (EMIF_BASE_ADDR + 0x0A0)
#define EMIF_IRQSTATUS_RAW_SYS_REG        (EMIF_BASE_ADDR + 0x0A4)
#define EMIF_IRQSTATUS_SYS_REG            (EMIF_BASE_ADDR + 0x0AC)
#define EMIF_IRQENABLE_SET_SYS_REG        (EMIF_BASE_ADDR + 0x0B4)
#define EMIF_IRQENABLE_CLR_SYS_REG        (EMIF_BASE_ADDR + 0x0BC)
#define EMIF_ZQ_CONFIG_REG                (EMIF_BASE_ADDR + 0x0C8)
#define EMIF_TEMP_ALERT_CONFIG_REG        (EMIF_BASE_ADDR + 0x0CC)
#define EMIF_OCP_ERR_LOG_REG              (EMIF_BASE_ADDR + 0x0D0)
#define EMIF_RDWR_LVL_RMP_WIN_REG         (EMIF_BASE_ADDR + 0x0D4)
#define EMIF_RDWR_LVL_RMP_CTRL_REG        (EMIF_BASE_ADDR + 0x0D8)
#define EMIF_RDWR_LVL_CTRL_REG            (EMIF_BASE_ADDR + 0x0DC)
#define EMIF_DDR_PHY_CTRL_1_REG           (EMIF_BASE_ADDR + 0x0E4)
#define EMIF_DDR_PHY_CTRL_1_SHDW_REG      (EMIF_BASE_ADDR + 0x0E8)
#define EMIF_DDR_PHY_CTRL_2_REG           (EMIF_BASE_ADDR + 0x0EC)
#define EMIF_PRI_COS_MAP_REG              (EMIF_BASE_ADDR + 0x100)
#define EMIF_CONNID_COS_1_MAP_REG         (EMIF_BASE_ADDR + 0x104)
#define EMIF_CONNID_COS_2_MAP_REG         (EMIF_BASE_ADDR + 0x108)
#define EMIF_RD_WR_EXEC_THRSH_REG         (EMIF_BASE_ADDR + 0x120)


//*******************************************************************
//DDR PHY registers
//*******************************************************************
#define    DDR_PHY_BASE_ADDR                                   (0x44E12000)  
//CMD0
#define    CMD0_REG_PHY_CTRL_SLAVE_RATIO_0                     (0x01C + DDR_PHY_BASE_ADDR)
#define    CMD0_REG_PHY_CTRL_SLAVE_FORCE_0                     (0x020 + DDR_PHY_BASE_ADDR)
#define    CMD0_REG_PHY_CTRL_SLAVE_DELAY_0                     (0x024 + DDR_PHY_BASE_ADDR)
#define    CMD0_REG_PHY_DLL_LOCK_DIFF_0                        (0x028 + DDR_PHY_BASE_ADDR)
#define    CMD0_REG_PHY_INVERT_CLKOUT_0                        (0x02C + DDR_PHY_BASE_ADDR)
#define    CMD0_PHY_REG_STATUS_PHY_CTRL_DLL_LOCK_0             (0x030 + DDR_PHY_BASE_ADDR)
#define    CMD0_PHY_REG_STATUS_PHY_CTRL_OF_IN_LOCK_STATE_0     (0x034 + DDR_PHY_BASE_ADDR)
#define    CMD0_PHY_REG_STATUS_PHY_CTRL_OF_IN_DELAY_VALUE_0    (0x038 + DDR_PHY_BASE_ADDR)
#define    CMD0_PHY_REG_STATUS_PHY_CTRL_OF_OUT_DELAY_VALUE_0   (0x03C + DDR_PHY_BASE_ADDR)

//CMD1
#define    CMD1_REG_PHY_CTRL_SLAVE_RATIO_0                     (0x050 + DDR_PHY_BASE_ADDR)
#define    CMD1_REG_PHY_CTRL_SLAVE_FORCE_0                     (0x054 + DDR_PHY_BASE_ADDR)
#define    CMD1_REG_PHY_CTRL_SLAVE_DELAY_0                     (0x058 + DDR_PHY_BASE_ADDR)
#define    CMD1_REG_PHY_DLL_LOCK_DIFF_0                        (0x05C + DDR_PHY_BASE_ADDR)
#define    CMD1_REG_PHY_INVERT_CLKOUT_0                        (0x060 + DDR_PHY_BASE_ADDR)
#define    CMD1_PHY_REG_STATUS_PHY_CTRL_DLL_LOCK_0             (0x064 + DDR_PHY_BASE_ADDR)
#define    CMD1_PHY_REG_STATUS_PHY_CTRL_OF_IN_LOCK_STATE_0     (0x068 + DDR_PHY_BASE_ADDR)
#define    CMD1_PHY_REG_STATUS_PHY_CTRL_OF_IN_DELAY_VALUE_0    (0x06C + DDR_PHY_BASE_ADDR)
#define    CMD1_PHY_REG_STATUS_PHY_CTRL_OF_OUT_DELAY_VALUE_0   (0x070 + DDR_PHY_BASE_ADDR)

//CMD2
#define    CMD2_REG_PHY_CTRL_SLAVE_RATIO_0                     (0x084 + DDR_PHY_BASE_ADDR)
#define    CMD2_REG_PHY_CTRL_SLAVE_FORCE_0                     (0x088 + DDR_PHY_BASE_ADDR)
#define    CMD2_REG_PHY_CTRL_SLAVE_DELAY_0                     (0x08C + DDR_PHY_BASE_ADDR)
#define    CMD2_REG_PHY_DLL_LOCK_DIFF_0                        (0x090 + DDR_PHY_BASE_ADDR)
#define    CMD2_REG_PHY_INVERT_CLKOUT_0                        (0x094 + DDR_PHY_BASE_ADDR)
#define    CMD2_PHY_REG_STATUS_PHY_CTRL_DLL_LOCK_0             (0x098 + DDR_PHY_BASE_ADDR)
#define    CMD2_PHY_REG_STATUS_PHY_CTRL_OF_IN_LOCK_STATE_0     (0x09C + DDR_PHY_BASE_ADDR)
#define    CMD2_PHY_REG_STATUS_PHY_CTRL_OF_IN_DELAY_VALUE_0    (0x0A0 + DDR_PHY_BASE_ADDR)
#define    CMD2_PHY_REG_STATUS_PHY_CTRL_OF_OUT_DELAY_VALUE_0   (0x0A4 + DDR_PHY_BASE_ADDR)

//DATA0
#define    DATA0_REG_PHY_DATA_SLICE_IN_USE_0                   (0x0B8 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_DIS_CALIB_RST_0                       (0x0BC + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_RDC_FIFO_RST_ERR_CNT_CLR_0            (0x0C0 + DDR_PHY_BASE_ADDR)
#define    DATA0_PHY_RDC_FIFO_RST_ERR_CNT_0                    (0x0C4 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_RD_DQS_SLAVE_RATIO_0                  (0x0C8 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_RD_DQS_SLAVE_RATIO_1                  (0x0CC + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_RD_DQS_SLAVE_FORCE_0                  (0x0D0 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_RD_DQS_SLAVE_DELAY_0                  (0x0D4 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_RD_DQS_SLAVE_DELAY_1                  (0x0D8 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DQS_SLAVE_RATIO_0                  (0x0DC + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DQS_SLAVE_RATIO_1                  (0x0E0 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DQS_SLAVE_FORCE_0                  (0x0E4 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DQS_SLAVE_DELAY_0                  (0x0E8 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DQS_SLAVE_DELAY_1                  (0x0EC + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WRLVL_INIT_RATIO_0                    (0x0F0 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WRLVL_INIT_RATIO_1                    (0x0F4 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WRLVL_INIT_MODE_0                     (0x0F8 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_GATELVL_INIT_RATIO_0                  (0x0FC + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_GATELVL_INIT_RATIO_1                  (0x100 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_GATELVL_INIT_MODE_0                   (0x104 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_FIFO_WE_SLAVE_RATIO_0                 (0x108 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_FIFO_WE_SLAVE_RATIO_1                 (0x10C + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_FIFO_WE_IN_FORCE_0                    (0x110 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_FIFO_WE_IN_DELAY_0                    (0x114 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_FIFO_WE_IN_DELAY_1                    (0x118 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_DQ_OFFSET_0                           (0x11C + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DATA_SLAVE_RATIO_0                 (0x120 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DATA_SLAVE_RATIO_1                 (0x124 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DATA_SLAVE_FORCE_0                 (0x128 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DATA_SLAVE_DELAY_0                 (0x12C + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_WR_DATA_SLAVE_DELAY_1                 (0x130 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_USE_RANK0_DELAYS_0                    (0x134 + DDR_PHY_BASE_ADDR)
#define    DATA0_REG_PHY_DLL_LOCK_DIFF_0                       (0x138 + DDR_PHY_BASE_ADDR)
#define    DATA0_PHY_REG_STATUS_DLL_LOCK_0                     (0x13C + DDR_PHY_BASE_ADDR)
#define    DATA0_PHY_REG_STATUS_OF_IN_LOCK_STATE_0             (0x140 + DDR_PHY_BASE_ADDR)
#define    DATA0_PHY_REG_STATUS_OF_IN_DELAY_VALUE_0            (0x144 + DDR_PHY_BASE_ADDR)
#define    DATA0_PHY_REG_STATUS_OF_OUT_DELAY_VALUE_0           (0x148 + DDR_PHY_BASE_ADDR)

//DATA1
#define    DATA1_REG_PHY_DATA_SLICE_IN_USE_0                   (0x15C + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_DIS_CALIB_RST_0                       (0x160 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_RDC_FIFO_RST_ERR_CNT_CLR_0            (0x164 + DDR_PHY_BASE_ADDR)
#define    DATA1_PHY_RDC_FIFO_RST_ERR_CNT_0                    (0x168 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_RD_DQS_SLAVE_RATIO_0                  (0x16C + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_RD_DQS_SLAVE_RATIO_1                  (0x170 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_RD_DQS_SLAVE_FORCE_0                  (0x174 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_RD_DQS_SLAVE_DELAY_0                  (0x178 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_RD_DQS_SLAVE_DELAY_1                  (0x17C + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DQS_SLAVE_RATIO_0                  (0x180 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DQS_SLAVE_RATIO_1                  (0x184 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DQS_SLAVE_FORCE_0                  (0x188 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DQS_SLAVE_DELAY_0                  (0x18C + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DQS_SLAVE_DELAY_1                  (0x190 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WRLVL_INIT_RATIO_0                    (0x194 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WRLVL_INIT_RATIO_1                    (0x198 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WRLVL_INIT_MODE_0                     (0x19C + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_GATELVL_INIT_RATIO_0                  (0x1A0 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_GATELVL_INIT_RATIO_1                  (0x1A4 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_GATELVL_INIT_MODE_0                   (0x1A8 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_FIFO_WE_SLAVE_RATIO_0                 (0x1AC + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_FIFO_WE_SLAVE_RATIO_1                 (0x1B0 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_FIFO_WE_IN_FORCE_0                    (0x1B4 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_FIFO_WE_IN_DELAY_0                    (0x1B8 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_FIFO_WE_IN_DELAY_1                    (0x1BC + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_DQ_OFFSET_0                           (0x1C0 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DATA_SLAVE_RATIO_0                 (0x1C4 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DATA_SLAVE_RATIO_1                 (0x1C8 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DATA_SLAVE_FORCE_0                 (0x1CC + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DATA_SLAVE_DELAY_0                 (0x1D0 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_WR_DATA_SLAVE_DELAY_1                 (0x1D4 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_USE_RANK0_DELAYS_0                    (0x1D8 + DDR_PHY_BASE_ADDR)
#define    DATA1_REG_PHY_DLL_LOCK_DIFF_0                       (0x1DC + DDR_PHY_BASE_ADDR)
#define    DATA1_PHY_REG_STATUS_DLL_LOCK_0                     (0x1E0 + DDR_PHY_BASE_ADDR)
#define    DATA1_PHY_REG_STATUS_OF_IN_LOCK_STATE_0             (0x1E4 + DDR_PHY_BASE_ADDR)
#define    DATA1_PHY_REG_STATUS_OF_IN_DELAY_VALUE_0            (0x1E8 + DDR_PHY_BASE_ADDR)
#define    DATA1_PHY_REG_STATUS_OF_OUT_DELAY_VALUE_0           (0x1EC + DDR_PHY_BASE_ADDR)

//FIFO
#define FIFO_WE_OUT0_IO_CONFIG_I_0                             (0x338 + DDR_PHY_BASE_ADDR)
#define FIFO_WE_OUT0_IO_CONFIG_SR_0                            (0x33C + DDR_PHY_BASE_ADDR)
#define FIFO_WE_OUT1_IO_CONFIG_I_0                             (0x340 + DDR_PHY_BASE_ADDR)
#define FIFO_WE_OUT1_IO_CONFIG_SR_0                            (0x344 + DDR_PHY_BASE_ADDR)
#define FIFO_WE_IN2_IO_CONFIG_I_0                              (0x348 + DDR_PHY_BASE_ADDR)
#define FIFO_WE_IN2_IO_CONFIG_SR_0                             (0x34C + DDR_PHY_BASE_ADDR)
#define FIFO_WE_IN3_IO_CONFIG_I_0                              (0x350 + DDR_PHY_BASE_ADDR)
#define FIFO_WE_IN3_IO_CONFIG_SR_0                             (0x354 + DDR_PHY_BASE_ADDR)

//Leveling
#define DATA0_REG_PHY_WRLVL_NUM_OF_DQ0                         (0x35C + DDR_PHY_BASE_ADDR)
#define DATA0_REG_PHY_GATELVL_NUM_OF_DQ0                       (0x360 + DDR_PHY_BASE_ADDR)
#define DATA1_REG_PHY_WRLVL_NUM_OF_DQ0                         (0x364 + DDR_PHY_BASE_ADDR)
#define DATA1_REG_PHY_GATELVL_NUM_OF_DQ0                       (0x368 + DDR_PHY_BASE_ADDR)


//*******************************************************************
//Watchdog Timer registers
//*******************************************************************
#define    WDT1_BASE_ADDR                                        (0x44E35000)  
#define    WDT1_WSPR                                             (WDT1_BASE_ADDR + 0x48)

//*****************************************************************************
//Read write prototype
//*****************************************************************************
#define WR_MEM_32(addr, data) *(unsigned int*)(addr) = (unsigned int)(data)
#define RD_MEM_32(addr)       *(unsigned int*)(addr)
#define UWORD32               unsigned int

//*****************************************************************************
//Global variables
//*****************************************************************************
UWORD32 CLKIN;


//*****************************************************************************
//Global Functions
//*****************************************************************************

//Watchdog is disabled to eliminate warm resets during debug
Disable_Watchdog()
{
    WR_MEM_32(WDT1_WSPR,0x0000AAAA);
    WR_MEM_32(WDT1_WSPR,0x00005555);
}

//Set the processor to ARM mode and Supervisor mode after a file is loaded, on a 
//restart or on a reset
//This will facilitate code loading and debug by putting the processor in a known
//state


AM335xStartState()
{
  CPSR &= ~0x20;
  CPSR = (CPSR & ~0x1F) | 0x13;   
}


OnFileLoaded()
{
   AM335xStartState();
}

OnRestart()
{
   AM335xStartState();     
}

OnReset()
{
   AM335xStartState();
   Disable_Watchdog();
}

OnTargetConnect()
{
    GEL_MapOff();
    GEL_MapReset();
    GEL_MapAddStr(0x00020000, 0, 0x20000000, "R", 0);    // Boot ROM
    GEL_MapAddStr(0x40000000, 0, 0x0002C000, "R", 0);    // Boot ROM (also at 0x20000)
    GEL_MapAddStr(0x402F0400, 0, 0x0000FC00, "R|W", 0);  // SRAM Internal
    GEL_MapAddStr(0x40300000, 0, 0x00010000, "R|W", 0);  // OCMC-RAM
    GEL_MapAddStr(0x44000000, 0, 0x00400000, "R|W", 0);  // L3F CFG Regs
    GEL_MapAddStr(0x44800000, 0, 0x00400000, "R|W", 0);  // L3S CFG Regs
    GEL_MapAddStr(0x44C00000, 0, 0x00400000, "R|W", 0);  // L4_WKUP
    GEL_MapAddStr(0x46000000, 0, 0x00400000, "R|W", 0);  // McASP0 Data
    GEL_MapAddStr(0x46400000, 0, 0x00400000, "R|W", 0);  // McASP1 Data
    GEL_MapAddStr(0x47400000, 0, 0x00005000, "R|W", 0);  // USB0/1
    GEL_MapAddStr(0x47810000, 0, 0x00010000, "R|W", 0);  // MMCHS2
    GEL_MapAddStr(0x48000000, 0, 0x01000000, "R|W", 0);  // L4 PER
    GEL_MapAddStr(0x49000000, 0, 0x00B00000, "R|W", 0);  // EDMA
    GEL_MapAddStr(0x4A000000, 0, 0x01000000, "R|W", 0);  // L4_FAST
    GEL_MapAddStr(0x4C000000, 0, 0x01000000, "R|W", 0);  // EMIF
    GEL_MapAddStr(0x50000000, 0, 0x01000000, "R|W", 0);  // GPMC Regs
    GEL_MapAddStr(0x56000000, 0, 0x01000000, "R|W", 0);  // SGX530
    GEL_MapAddStr(0x80000000, 0, 0x40000000, "R|W", 0);  // 256MB DDR3 external memory
    GEL_MapOn();
    AM335xStartState();
    AM3358_SK_Initialization();
    Disable_Watchdog();

}

//******************************************************************************
//System Initialization
//******************************************************************************

menuitem "AM335x System Initialization"

hotmenu AM3358_SK_Initialization()
    {
    GEL_TextOut("****  AM3358_SK Initialization is in progress .......... \n","Output",1,1,1);    
    ARM_OPP100_Config();
    DDR3_EMIF_Config();
    GEL_TextOut("****  AM3358_SK Initialization is Done ****************** \n\n\n","Output",1,1,1);   
    }

hotmenu GetInputClockFrequency()
{
    UWORD32 temp;
    
    temp = RD_MEM_32(CONTROL_STATUS) >> 22;
    temp = temp & 0x3;
    if (temp == 0)
    {   
        CLKIN = 19;  //19.2MHz
        GEL_TextOut("Input Clock Read from SYSBOOT[15:14]:  19.2MHz\n","Output",1,1,1);
    }   
    if (temp == 1)
    {
        CLKIN = 24;  //24MHz
        GEL_TextOut("Input Clock Read from SYSBOOT[15:14]:  24MHz\n","Output",1,1,1);
    }   
    if (temp == 2)
    {
        CLKIN = 25;  //25MHz
        GEL_TextOut("Input Clock Read from SYSBOOT[15:14]:  25MHz\n","Output",1,1,1);
    }   
    if (temp == 3)
    { 
        CLKIN = 26;  //26MHz
        GEL_TextOut("Input Clock Read from SYSBOOT[15:14]:  26MHz\n","Output",1,1,1);
    }   
}

hotmenu ARM_Turbo_Config()
{
unsigned int i;
GEL_TextOut("************************************************************************ \n","Output",1,1,1);
GEL_TextOut("****  NOTE:  VDD_MPU must be set to 1.26V for Turbo mode to work!!! **** \n","Output",1,1,1);
GEL_TextOut("************************************************************************ \n","Output",1,1,1);
for(i=0;i<100000;i++);
GEL_TextOut("****  AM335x ALL PLL Config for OPP == Turbo is in progress ......... \n","Output",1,1,1);
GetInputClockFrequency();
if(CLKIN==24)
{
   MPU_PLL_Config(  CLKIN, 23, 720, 1);
   CORE_PLL_Config( CLKIN, 23, 1000, 10, 8, 4);
   DDR_PLL_Config(  CLKIN, 23, 303, 1);
   PER_PLL_Config(  CLKIN, 23, 960, 5);
   DISP_PLL_Config( CLKIN, 23, 48, 1);
   GEL_TextOut(" ****  AM335x ALL PLL Config for OPP == Turbo is done ......... \n","Output",1,1,1);
}
else
   GEL_TextOut("****  AM335x PLL Config failed!!  Check SYSBOOT[15:14] for proper input freq config \n","Output",1,1,1);
}

hotmenu ARM_OPP120_Config()
{
unsigned int i;
GEL_TextOut("************************************************************************ \n","Output",1,1,1);
GEL_TextOut("****  NOTE:  VDD_MPU must be set to 1.2V for OPP120 mode to work!!! **** \n","Output",1,1,1);
GEL_TextOut("************************************************************************ \n","Output",1,1,1);
for(i=0;i<100000;i++);
GEL_TextOut("****  AM335x ALL PLL Config for OPP == OPP120 is in progress ......... \n","Output",1,1,1);
GetInputClockFrequency();
if(CLKIN==24)
{
   MPU_PLL_Config(  CLKIN, 23, 650, 1);
   CORE_PLL_Config( CLKIN, 23, 1000, 10, 8, 4);
   DDR_PLL_Config(  CLKIN, 23, 303, 1);
   PER_PLL_Config(  CLKIN, 23, 960, 5);
   DISP_PLL_Config( CLKIN, 23, 48, 1);
   GEL_TextOut(" ****  AM335x ALL ADPLL Config for OPP == OPP120 is done ......... \n","Output",1,1,1);
}
else 
   GEL_TextOut("****  AM335x PLL Config failed!!  Check SYSBOOT[15:14] for proper input freq config \n","Output",1,1,1);
}

hotmenu ARM_OPP100_Config()
{
GEL_TextOut("****  AM335x ALL PLL Config for OPP == OPP100 is in progress ......... \n","Output",1,1,1);
GetInputClockFrequency();
if(CLKIN==24)
{
   MPU_PLL_Config(  CLKIN, 23, 550, 1);
   CORE_PLL_Config( CLKIN, 23, 1000, 10, 8, 4);
   DDR_PLL_Config(  CLKIN, 23, 303, 1);
   PER_PLL_Config(  CLKIN, 23, 960, 5);
   DISP_PLL_Config( CLKIN, 23, 48, 1);
   GEL_TextOut("****  AM335x ALL ADPLL Config for OPP == OPP100 is Done ......... \n","Output",1,1,1);
}
else 
   GEL_TextOut("****  AM335x PLL Config failed!!  Check SYSBOOT[15:14] for proper input freq config \n","Output",1,1,1);
}

//**********************************************************************
//PLL Configuration functions
//**********************************************************************
MPU_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
{
UWORD32 ref_clk,clk_out = 0;
UWORD32 clkmode,clksel,div_m2,idlest_dpll;
UWORD32 temp,i;

ref_clk     = CLKIN/(N+1);
clk_out     = (ref_clk*M)/M2;

clkmode=RD_MEM_32(CM_CLKMODE_DPLL_MPU);
clksel= RD_MEM_32(CM_CLKSEL_DPLL_MPU);
div_m2= RD_MEM_32(CM_DIV_M2_DPLL_MPU);

GEL_TextOut("****  Going to Bypass... \n","Output",1,1,1);

//put the DPLL in bypass mode
WR_MEM_32(CM_CLKMODE_DPLL_MPU,0x4);

while(((RD_MEM_32(CM_IDLEST_DPLL_MPU) & 0x101) != 0x00000100)); //wait for bypass status

GEL_TextOut("****  Bypassed, changing values... \n","Output",1,1,1);

//set multiply and divide values
clksel = clksel & (~0x7FFFF);
clksel = clksel | ((M <<0x8) | N);
WR_MEM_32(CM_CLKSEL_DPLL_MPU,clksel);
div_m2 = div_m2 & ~0x1F;
div_m2 = div_m2 | M2;  
WR_MEM_32(CM_DIV_M2_DPLL_MPU,div_m2);

GEL_TextOut("****  Locking ARM PLL\n","Output",1,1,1);
//now lock the DPLL
clkmode = clkmode | 0x7;  //enables lock mode
WR_MEM_32(CM_CLKMODE_DPLL_MPU,clkmode);
while(((RD_MEM_32(CM_IDLEST_DPLL_MPU) & 0x101) != 0x1)); //wait for lock
}

CORE_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M4,UWORD32 M5,UWORD32 M6)
{
UWORD32 ref_clk,clk_out4,clk_out5,clk_out6;
UWORD32 clkmode,clksel,div_m4,div_m5,div_m6,idlest_dpll;

ref_clk     = CLKIN/(N+1);
clk_out4     = (ref_clk*M)/M4;  //M4=200MHz
clk_out5     = (ref_clk*M)/M5;  //M5=250MHz
clk_out6     = (ref_clk*M)/M6;  //M6=500MHz

clkmode=RD_MEM_32(CM_CLKMODE_DPLL_CORE);
clksel= RD_MEM_32(CM_CLKSEL_DPLL_CORE);
div_m4= RD_MEM_32(CM_DIV_M4_DPLL_CORE); 
div_m5= RD_MEM_32(CM_DIV_M5_DPLL_CORE); 
div_m6= RD_MEM_32(CM_DIV_M6_DPLL_CORE); 

//put DPLL in bypass mode
clkmode = (clkmode & 0xfffffff8)|0x00000004;
WR_MEM_32(CM_CLKMODE_DPLL_CORE,clkmode);
while((RD_MEM_32(CM_IDLEST_DPLL_CORE) & 0x00000100 )!=0x00000100); //wait for bypass status

GEL_TextOut("****  Core Bypassed\n","Output",1,1,1);

//set multiply and divide values
clksel = clksel & (~0x7FFFF);
clksel = clksel | ((M <<0x8) | N);
WR_MEM_32(CM_CLKSEL_DPLL_CORE,clksel);
div_m4= M4;   //200MHz
WR_MEM_32(CM_DIV_M4_DPLL_CORE,div_m4);
div_m5=  M5;  //250MHz
WR_MEM_32(CM_DIV_M5_DPLL_CORE,div_m5);
div_m6=  M6;  //500MHz
WR_MEM_32(CM_DIV_M6_DPLL_CORE,div_m6);

GEL_TextOut("****  Now locking Core...\n","Output",1,1,1);

//now lock the PLL
clkmode =(clkmode&0xfffffff8)|0x00000007;
WR_MEM_32(CM_CLKMODE_DPLL_CORE,clkmode);

while((RD_MEM_32(CM_IDLEST_DPLL_CORE) & 0x00000001 )!=0x00000001);
GEL_TextOut("****  Core locked\n","Output",1,1,1);
}

DDR_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
{
UWORD32 ref_clk,clk_out = 0;
UWORD32 clkmode,clksel,div_m2,idlest_dpll;

ref_clk     = CLKIN/(N+1);
clk_out     = (ref_clk*M)/M2;

clkmode=RD_MEM_32(CM_CLKMODE_DPLL_DDR);
clksel= RD_MEM_32(CM_CLKSEL_DPLL_DDR);
div_m2= RD_MEM_32(CM_DIV_M2_DPLL_DDR);

clkmode =(clkmode&0xfffffff8)|0x00000004;
WR_MEM_32(CM_CLKMODE_DPLL_DDR,clkmode);
while((RD_MEM_32(CM_IDLEST_DPLL_DDR) & 0x00000100 )!=0x00000100);

GEL_TextOut("****  DDR DPLL Bypassed\n","Output",1,1,1);

clksel = clksel & (~0x7FFFF);
clksel = clksel | ((M <<0x8) | N);
WR_MEM_32(CM_CLKSEL_DPLL_DDR,clksel);
div_m2 = RD_MEM_32(CM_DIV_M2_DPLL_DDR);
div_m2 = (div_m2&0xFFFFFFE0) | M2;
WR_MEM_32(CM_DIV_M2_DPLL_DDR,div_m2);
clkmode =(clkmode&0xfffffff8)|0x00000007;
WR_MEM_32(CM_CLKMODE_DPLL_DDR,clkmode);


while((RD_MEM_32(CM_IDLEST_DPLL_DDR) & 0x00000001 )!=0x00000001);

GEL_TextOut("****  DDR DPLL Locked\n","Output",1,1,1);
}

PER_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
{
UWORD32 ref_clk,clk_out = 0;
UWORD32 clkmode,clksel,div_m2,idlest_dpll;

ref_clk     = CLKIN/(N+1);
clk_out     = (ref_clk*M)/M2;

clkmode=RD_MEM_32(CM_CLKMODE_DPLL_PER);
clksel= RD_MEM_32(CM_CLKSEL_DPLL_PER);
div_m2= RD_MEM_32(CM_DIV_M2_DPLL_PER);

clkmode =(clkmode&0xfffffff8)|0x00000004;
WR_MEM_32(CM_CLKMODE_DPLL_PER,clkmode);
while((RD_MEM_32(CM_IDLEST_DPLL_PER) & 0x00000100 )!=0x00000100);

GEL_TextOut("****  PER DPLL Bypassed\n","Output",1,1,1);

clksel = clksel & (~0x7FFFF);
clksel = clksel | ((M <<0x8) | N);
WR_MEM_32(CM_CLKSEL_DPLL_PER,clksel);
div_m2= 0xFFFFFF80 | M2;
WR_MEM_32(CM_DIV_M2_DPLL_PER,div_m2);
clkmode =(clkmode&0xfffffff8)|0x00000007;
WR_MEM_32(CM_CLKMODE_DPLL_PER,clkmode);

while((RD_MEM_32(CM_IDLEST_DPLL_PER) & 0x00000001 )!=0x00000001);

GEL_TextOut("****  PER DPLL Locked\n","Output",1,1,1);
}

DISP_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
{
UWORD32 ref_clk,clk_out = 0;
UWORD32 clkmode,clksel,div_m2,idlest_dpll;

GEL_TextOut("****  DISP PLL Config is in progress .......... \n","Output",1,1,1);    

ref_clk     = CLKIN/(N+1);
clk_out     = (ref_clk*M)/M2;

clkmode=RD_MEM_32(CM_CLKMODE_DPLL_DISP);
clksel= RD_MEM_32(CM_CLKSEL_DPLL_DISP);
div_m2= RD_MEM_32(CM_DIV_M2_DPLL_DISP);

clkmode =(clkmode&0xfffffff8)|0x00000004;
WR_MEM_32(CM_CLKMODE_DPLL_DISP,clkmode);
while((RD_MEM_32(CM_IDLEST_DPLL_DISP) & 0x00000100 )!=0x00000100);

clksel = clksel & (~0x7FFFF);
clksel = clksel | ((M <<0x8) | N);
WR_MEM_32(CM_CLKSEL_DPLL_DISP,clksel);
div_m2= 0xFFFFFFE0 | M2;
WR_MEM_32(CM_DIV_M2_DPLL_DISP,div_m2);
clkmode =(clkmode&0xfffffff8)|0x00000007;
WR_MEM_32(CM_CLKMODE_DPLL_DISP,clkmode);

while((RD_MEM_32(CM_IDLEST_DPLL_DISP) & 0x00000001 )!=0x00000001);

GEL_TextOut("****  DISP PLL Config is DONE .......... \n","Output",1,1,1);
}


//************************************************************************
//This function enables the L3 and L4_WKUP interface clocks.    
//This also enables the functional clock for GPIO0 instance.                                               *
//************************************************************************
GPIO0ModuleClkConfig()
{
    /* Configuring L3 Interface Clocks. */

    /* Writing to MODULEMODE field of CM_PER_L3_CLKCTRL register. */
    WR_MEM_32(CM_PER_L3_CLKCTRL, (RD_MEM_32(CM_PER_L3_CLKCTRL)|CM_PER_L3_CLKCTRL_MODULEMODE_ENABLE));

    /* Waiting for MODULEMODE field to reflect the written value. */
    while(CM_PER_L3_CLKCTRL_MODULEMODE_ENABLE !=(RD_MEM_32(CM_PER_L3_CLKCTRL) & CM_PER_L3_CLKCTRL_MODULEMODE));

    /* Writing to MODULEMODE field of CM_PER_L3_INSTR_CLKCTRL register. */
    WR_MEM_32(CM_PER_L3_INSTR_CLKCTRL, (RD_MEM_32(CM_PER_L3_INSTR_CLKCTRL)|CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_ENABLE));

    /* Waiting for MODULEMODE field to reflect the written value. */
    while(CM_PER_L3_INSTR_CLKCTRL_MODULEMODE_ENABLE != (RD_MEM_32(CM_PER_L3_INSTR_CLKCTRL) & CM_PER_L3_INSTR_CLKCTRL_MODULEMODE));

    /* Writing to CLKTRCTRL field of CM_PER_L3_CLKSTCTRL register. */
    WR_MEM_32(CM_PER_L3_CLKSTCTRL, (RD_MEM_32(CM_PER_L3_CLKSTCTRL)|CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP));

    /* Waiting for CLKTRCTRL field to reflect the written value. */
    while(CM_PER_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (RD_MEM_32(CM_PER_L3_CLKSTCTRL) & CM_PER_L3_CLKSTCTRL_CLKTRCTRL)); 
        
    /* Writing to CLKTRCTRL field of CM_PER_OCPWP_L3_CLKSTCTRL register. */
    WR_MEM_32(CM_PER_OCPWP_L3_CLKSTCTRL, (RD_MEM_32(CM_PER_OCPWP_L3_CLKSTCTRL)| CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP));

    /*Waiting for CLKTRCTRL field to reflect the written value. */
    while(CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (RD_MEM_32(CM_PER_OCPWP_L3_CLKSTCTRL) & CM_PER_OCPWP_L3_CLKSTCTRL_CLKTRCTRL));
          
    /* Writing to CLKTRCTRL field of CM_PER_L3S_CLKSTCTRL register. */
    WR_MEM_32(CM_PER_L3S_CLKSTCTRL, (RD_MEM_32(CM_PER_L3S_CLKSTCTRL)| CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_WKUP));

    /*Waiting for CLKTRCTRL field to reflect the written value. */
    while(CM_PER_L3S_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (RD_MEM_32(CM_PER_L3S_CLKSTCTRL) & CM_PER_L3S_CLKSTCTRL_CLKTRCTRL));
    
    /* Checking fields for necessary values.  */

    /* Waiting for IDLEST field in CM_PER_L3_CLKCTRL register to be set to 0x0. */
    while((CM_PER_L3_CLKCTRL_IDLEST_FUNC << CM_PER_L3_CLKCTRL_IDLEST_SHIFT)!= (RD_MEM_32(CM_PER_L3_CLKCTRL) & CM_PER_L3_CLKCTRL_IDLEST)); 
    
    /*
    ** Waiting for IDLEST field in CM_PER_L3_INSTR_CLKCTRL register to attain the
    ** desired value.
    */
    while((CM_PER_L3_INSTR_CLKCTRL_IDLEST_FUNC << CM_PER_L3_INSTR_CLKCTRL_IDLEST_SHIFT)!= (RD_MEM_32(CM_PER_L3_INSTR_CLKCTRL) & CM_PER_L3_INSTR_CLKCTRL_IDLEST));
          
    /*
    ** Waiting for CLKACTIVITY_L3_GCLK field in CM_PER_L3_CLKSTCTRL register to
    ** attain the desired value.
    */
    while(CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK != (RD_MEM_32(CM_PER_L3_CLKSTCTRL) & CM_PER_L3_CLKSTCTRL_CLKACTIVITY_L3_GCLK)); 
          
    /*
    ** Waiting for CLKACTIVITY_OCPWP_L3_GCLK field in CM_PER_OCPWP_L3_CLKSTCTRL
    ** register to attain the desired value.
    */
    while(CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK != (RD_MEM_32(CM_PER_OCPWP_L3_CLKSTCTRL) & CM_PER_OCPWP_L3_CLKSTCTRL_CLKACTIVITY_OCPWP_L3_GCLK));
          
    /*
    ** Waiting for CLKACTIVITY_L3S_GCLK field in CM_PER_L3S_CLKSTCTRL register
    ** to attain the desired value.
    */
    while(CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK != (RD_MEM_32(CM_PER_L3S_CLKSTCTRL) & CM_PER_L3S_CLKSTCTRL_CLKACTIVITY_L3S_GCLK));

    /* Configuring registers related to Wake-Up region. */

    /* Writing to MODULEMODE field of CM_WKUP_CONTROL_CLKCTRL register. */
    WR_MEM_32(CM_WKUP_CONTROL_CLKCTRL, (RD_MEM_32(CM_WKUP_CONTROL_CLKCTRL)|CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE));
        
    /* Waiting for MODULEMODE field to reflect the written value. */
    while(CM_WKUP_CONTROL_CLKCTRL_MODULEMODE_ENABLE != (RD_MEM_32(CM_WKUP_CONTROL_CLKCTRL) & CM_WKUP_CONTROL_CLKCTRL_MODULEMODE)); 
    
    /* Writing to CLKTRCTRL field of CM_WKUP_CLKSTCTRL register. */
    WR_MEM_32(CM_WKUP_CLKSTCTRL, (RD_MEM_32(CM_WKUP_CONTROL_CLKCTRL)| CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_WKUP));

    /*Waiting for CLKTRCTRL field to reflect the written value. */
    while(CM_WKUP_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (RD_MEM_32(CM_WKUP_CLKSTCTRL) & CM_WKUP_CLKSTCTRL_CLKTRCTRL));  
          
    /* Writing to CLKTRCTRL field of CM_L3_AON_CLKSTCTRL register. */
    WR_MEM_32(CM_WKUP_CM_L3_AON_CLKSTCTRL, (RD_MEM_32(CM_WKUP_CM_L3_AON_CLKSTCTRL)| CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP));

    /*Waiting for CLKTRCTRL field to reflect the written value. */
    while(CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL_SW_WKUP != (RD_MEM_32(CM_WKUP_CM_L3_AON_CLKSTCTRL) & CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKTRCTRL)); 
    
    /* Writing to MODULEMODE field of CM_WKUP_GPIO0_CLKCTRL register. */
    WR_MEM_32(CM_WKUP_GPIO0_CLKCTRL, (RD_MEM_32(CM_WKUP_GPIO0_CLKCTRL)| CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_ENABLE));

    /* Waiting for MODULEMODE field to reflect the written value. */
    while(CM_WKUP_GPIO0_CLKCTRL_MODULEMODE_ENABLE != (RD_MEM_32(CM_WKUP_GPIO0_CLKCTRL) & CM_WKUP_GPIO0_CLKCTRL_MODULEMODE));
        
    /*
    ** Writing to OPTFCLKEN_GPIO0_GDBCLK field of CM_WKUP_GPIO0_CLKCTRL
    ** register.
    */
    WR_MEM_32(CM_WKUP_GPIO0_CLKCTRL, (RD_MEM_32(CM_WKUP_GPIO0_CLKCTRL)| CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK));

    /* Waiting for OPTFCLKEN_GPIO0_GDBCLK field to reflect the written value. */
    while(CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK != (RD_MEM_32(CM_WKUP_GPIO0_CLKCTRL) & CM_WKUP_GPIO0_CLKCTRL_OPTFCLKEN_GPIO0_GDBCLK)); 
    
    /* Verifying if the other bits are set to required settings. */

    /*
    ** Waiting for IDLEST field in CM_WKUP_CONTROL_CLKCTRL register to attain
    ** desired value.
    */
    while((CM_WKUP_CONTROL_CLKCTRL_IDLEST_FUNC << CM_WKUP_CONTROL_CLKCTRL_IDLEST_SHIFT) != (RD_MEM_32(CM_WKUP_CONTROL_CLKCTRL) & CM_WKUP_CONTROL_CLKCTRL_IDLEST));
    
    /*
    ** Waiting for CLKACTIVITY_L3_AON_GCLK field in CM_L3_AON_CLKSTCTRL
    ** register to attain desired value.
    */
    while(CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK !=  (RD_MEM_32(CM_WKUP_CM_L3_AON_CLKSTCTRL) & CM_WKUP_CM_L3_AON_CLKSTCTRL_CLKACTIVITY_L3_AON_GCLK)); 
          
    /*
    ** Waiting for IDLEST field in CM_WKUP_L4WKUP_CLKCTRL register to attain
    ** desired value.
    */
    while((CM_WKUP_L4WKUP_CLKCTRL_IDLEST_FUNC << CM_WKUP_L4WKUP_CLKCTRL_IDLEST_SHIFT) != (RD_MEM_32(CM_WKUP_L4WKUP_CLKCTRL) & CM_WKUP_L4WKUP_CLKCTRL_IDLEST)); 
    
    /*
    ** Waiting for CLKACTIVITY_L4_WKUP_GCLK field in CM_WKUP_CLKSTCTRL register
    ** to attain desired value.
    */
    while(CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK != (RD_MEM_32(CM_WKUP_CLKSTCTRL) & CM_WKUP_CLKSTCTRL_CLKACTIVITY_L4_WKUP_GCLK)); 
    
    /*
    ** Waiting for CLKACTIVITY_L4_WKUP_AON_GCLK field in CM_L4_WKUP_AON_CLKSTCTRL
    ** register to attain desired value.
    */
    while(CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK != (RD_MEM_32(CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL) & CM_WKUP_CM_L4_WKUP_AON_CLKSTCTRL_CLKACTIVITY_L4_WKUP_AON_GCLK));
    
    /* Writing to IDLEST field in CM_WKUP_GPIO0_CLKCTRL register. */
    while((CM_WKUP_GPIO0_CLKCTRL_IDLEST_FUNC << CM_WKUP_GPIO0_CLKCTRL_IDLEST_SHIFT) != (RD_MEM_32(CM_WKUP_GPIO0_CLKCTRL) & CM_WKUP_GPIO0_CLKCTRL_IDLEST)); 
    
    /*
    ** Waiting for CLKACTIVITY_GPIO0_GDBCLK field in CM_WKUP_GPIO0_CLKCTRL
    ** register to attain desired value.
    */
    while(CM_WKUP_CLKSTCTRL_CLKACTIVITY_GPIO0_GDBCLK != (RD_MEM_32(CM_WKUP_CLKSTCTRL) & CM_WKUP_CLKSTCTRL_CLKACTIVITY_GPIO0_GDBCLK)); 
    
}

//##############################################################################
//##############################################################################
//                       DDR Configuration Section
//##############################################################################
//##############################################################################

//******************************************************************
//DDR3=303MHz
//OPP100
//******************************************************************

//******************************************************************* 
//DDR3 PHY parameters
//*******************************************************************

#define  CMD_PHY_CTRL_SLAVE_RATIO       0x40
#define  CMD_PHY_INVERT_CLKOUT          0x1

#define  DATA_PHY_RD_DQS_SLAVE_RATIO    0x3B
#define  DATA_PHY_FIFO_WE_SLAVE_RATIO   0x100 //RD DQS GATE
#define  DATA_PHY_WR_DQS_SLAVE_RATIO    0x85
#define  DATA_PHY_WR_DATA_SLAVE_RATIO   0xC1  //WRITE DATA

#define  DDR_IOCTRL_VALUE               (0x18B)

//******************************************************************
//EMIF parameters
//******************************************************************
#define ALLOPP_DDR3_READ_LATENCY    0x06        //RD_Latency = (CL + 2) - 1   
#define ALLOPP_DDR3_SDRAM_TIMING1   0x0888A39B   
#define ALLOPP_DDR3_SDRAM_TIMING2   0x26337FDA   
#define ALLOPP_DDR3_SDRAM_TIMING3   0x501F830F

#define ALLOPP_DDR3_SDRAM_CONFIG    0x61C04AB2  //termination = 1 (RZQ/4)
                                                //dynamic ODT = 2 (RZQ/2)
                                                //SDRAM drive = 0 (RZQ/6)
                                                //CWL = 0 (CAS write latency = 5)
                                                //CL = 2 (CAS latency = 5)
                                                //ROWSIZE = 5 (14 row bits)
                                                //PAGESIZE = 2 (10 column bits)
#define ALLOPP_DDR3_REF_CTRL        0x0000093B  //303 * 7.8us = 0x93B
#define ALLOPP_DDR3_ZQ_CONFIG       0x50074BE4

menuitem "AM335x DDR Configuration";

hotmenu DDR3_EMIF_Config()
{
    UWORD32 i=0;
    
    GEL_TextOut("****  AM335x DDR3 EMIF and PHY configuration is in progress... \n","Output",1,1,1);
    
    EMIF_PRCM_CLK_ENABLE();

    GEL_TextOut("DDR PHY Configuration in progress \n","Output",1,1,1);
    
    GPIO0ModuleClkConfig();
    
    /*DDR_VTT_EN - GPIO0_7 PINMUX Setup*/ 
    WR_MEM_32(CONTROL_CONF_ECAP0_IN_PWM0_OUT, CONTROL_CONF_GPIO0_7);
                 
    /* Clearing the DISABLEMODULE bit in the Control(CTRL) register. */
    WR_MEM_32((SOC_GPIO_0_REGS + GPIO_CTRL),(RD_MEM_32(SOC_GPIO_0_REGS + GPIO_CTRL) & ~GPIO_CTRL_DISABLEMODULE));

    /*
    ** Setting the SOFTRESET bit in System Configuration register.
    ** Doing so would reset the GPIO module.
    */
    WR_MEM_32((SOC_GPIO_0_REGS +  GPIO_SYSCONFIG),(RD_MEM_32(SOC_GPIO_0_REGS + GPIO_SYSCONFIG) |GPIO_SYSCONFIG_SOFTRESET));
    
    /* Waiting until the GPIO Module is reset.*/    
 	while(!(RD_MEM_32(SOC_GPIO_0_REGS + GPIO_SYSSTATUS) & GPIO_SYSSTATUS_RESETDONE));

    /*Configuring GPIO0_7 as output*/
    WR_MEM_32((SOC_GPIO_0_REGS + GPIO_OE),(RD_MEM_32(SOC_GPIO_0_REGS + GPIO_OE) & ~(1 << 7))); 
    
   	/* Setting GPIO0_7 HIGH - Enable VTT Regulator DDR_VTT_EN */
    WR_MEM_32((SOC_GPIO_0_REGS + GPIO_SETDATAOUT), (1 << 7));
  
             
    //Write 0 to CLRZ bit
    WR_MEM_32(VTP_CTRL_REG ,(RD_MEM_32(VTP_CTRL_REG) & 0xFFFFFFFE));
    //Write 1 to CLRZ bit
    WR_MEM_32(VTP_CTRL_REG ,(RD_MEM_32(VTP_CTRL_REG) | 0x00000001));
    
    VTP_Enable();
 
    PHY_Config_CMD();
    PHY_Config_DATA();

    GEL_TextOut("Setting IO control registers....... \n","Output",1,1,1,i);
    WR_MEM_32(DDR_CMD0_IOCTRL,DDR_IOCTRL_VALUE);
    WR_MEM_32(DDR_CMD1_IOCTRL,DDR_IOCTRL_VALUE);
    WR_MEM_32(DDR_CMD2_IOCTRL,DDR_IOCTRL_VALUE);
    WR_MEM_32(DDR_DATA0_IOCTRL,DDR_IOCTRL_VALUE);
    WR_MEM_32(DDR_DATA1_IOCTRL,DDR_IOCTRL_VALUE);

    //IO to work for DDR3
    WR_MEM_32(DDR_IO_CTRL, RD_MEM_32(DDR_IO_CTRL) & ~0x10000000 );

    //CKE controlled by EMIF/DDR_PHY
    WR_MEM_32(DDR_CKE_CTRL, RD_MEM_32(DDR_CKE_CTRL) | 0x00000001);

    GEL_TextOut("EMIF Timing register configuration is in progress ....... \n","Output",1,1,1);

    WR_MEM_32(EMIF_DDR_PHY_CTRL_1_REG, ALLOPP_DDR3_READ_LATENCY);
    WR_MEM_32(EMIF_DDR_PHY_CTRL_1_SHDW_REG, ALLOPP_DDR3_READ_LATENCY);
    WR_MEM_32(EMIF_DDR_PHY_CTRL_2_REG, ALLOPP_DDR3_READ_LATENCY);

    WR_MEM_32(EMIF_SDRAM_TIM_1_REG,ALLOPP_DDR3_SDRAM_TIMING1);
    WR_MEM_32(EMIF_SDRAM_TIM_1_SHDW_REG,ALLOPP_DDR3_SDRAM_TIMING1);

    WR_MEM_32(EMIF_SDRAM_TIM_2_REG,ALLOPP_DDR3_SDRAM_TIMING2);
    WR_MEM_32(EMIF_SDRAM_TIM_2_SHDW_REG,ALLOPP_DDR3_SDRAM_TIMING2);

    WR_MEM_32(EMIF_SDRAM_TIM_3_REG,ALLOPP_DDR3_SDRAM_TIMING3);
    WR_MEM_32(EMIF_SDRAM_TIM_3_SHDW_REG,ALLOPP_DDR3_SDRAM_TIMING3);

    WR_MEM_32(EMIF_SDRAM_REF_CTRL_REG,ALLOPP_DDR3_REF_CTRL);
    WR_MEM_32(EMIF_SDRAM_REF_CTRL_SHDW_REG,ALLOPP_DDR3_REF_CTRL);
    
    WR_MEM_32(EMIF_ZQ_CONFIG_REG,ALLOPP_DDR3_ZQ_CONFIG);
    
    WR_MEM_32(EMIF_SDRAM_CONFIG_REG, ALLOPP_DDR3_SDRAM_CONFIG);

    GEL_TextOut("EMIF Timing register configuration is done ....... \n","Output",1,1,1);

    if((RD_MEM_32(EMIF_STATUS_REG) & 0x4) == 0x4)
    {
        GEL_TextOut("PHY is READY!!\n","Output",1,1,1);
    }

    GEL_TextOut("DDR PHY Configuration done \n","Output",1,1,1);
}


PHY_Config_CMD()
 	{
 	   UWORD32 i=0;
 	   for(i=0;i<3;i++)
	   {    
          GEL_TextOut("DDR PHY CMD%d Register configuration is in progress ....... \n","Output",1,1,1,i);

          WR_MEM_32(CMD0_REG_PHY_CTRL_SLAVE_RATIO_0 + (i*0x34),CMD_PHY_CTRL_SLAVE_RATIO);               
          WR_MEM_32(CMD0_REG_PHY_INVERT_CLKOUT_0    + (i*0x34),CMD_PHY_INVERT_CLKOUT);
	   }
}

PHY_Config_DATA()
{ 
	UWORD32 i;	
	for(i=0;i<2;i++)
	{
        GEL_TextOut("DDR PHY DATA%d Register configuration is in progress ....... \n","Output",1,1,1,i);
    
        WR_MEM_32(DATA0_REG_PHY_RD_DQS_SLAVE_RATIO_0     + (i*0xA4),DATA_PHY_RD_DQS_SLAVE_RATIO);
        WR_MEM_32(DATA0_REG_PHY_WR_DQS_SLAVE_RATIO_0     + (i*0xA4),DATA_PHY_WR_DQS_SLAVE_RATIO);
        WR_MEM_32(DATA0_REG_PHY_FIFO_WE_SLAVE_RATIO_0    + (i*0xA4),DATA_PHY_FIFO_WE_SLAVE_RATIO);
        WR_MEM_32(DATA0_REG_PHY_WR_DATA_SLAVE_RATIO_0    + (i*0xA4),DATA_PHY_WR_DATA_SLAVE_RATIO);
	}
}

hotmenu EMIF_PRCM_CLK_ENABLE()
{
    GEL_TextOut("EMIF PRCM is in progress ....... \n","Output",1,1,1);
    /* Enable EMIF4 Firewall clocks*/
    WR_MEM_32(CM_PER_EMIF_FW_CLKCTRL,0x02);
    /* Enable EMIF4 clocks*/
    WR_MEM_32(CM_PER_EMIF_CLKCTRL,0x02);
    /* Poll if module is functional */
    while(RD_MEM_32(CM_PER_EMIF_CLKCTRL)!= 0x02);
    GEL_TextOut("EMIF PRCM Done \n","Output",1,1,1);
}

//************************************************************************
//VTP_Enable() routine                                                   *
//************************************************************************

VTP_Enable()
{
      //Write 1 to enable VTP
      WR_MEM_32(VTP_CTRL_REG ,(RD_MEM_32(VTP_CTRL_REG) | 0x00000040));
      //Write 0 to CLRZ bit
      WR_MEM_32(VTP_CTRL_REG ,(RD_MEM_32(VTP_CTRL_REG) & 0xFFFFFFFE));
      //Write 1 to CLRZ bit
      WR_MEM_32(VTP_CTRL_REG ,(RD_MEM_32(VTP_CTRL_REG) | 0x00000001));
     //Check for VTP ready bit
      GEL_TextOut("Waiting for VTP Ready ....... \n","Output",1,1,1);
      while((RD_MEM_32(VTP_CTRL_REG) & 0x00000020) != 0x00000020);    
      GEL_TextOut("VTP is Ready! \n","Output",1,1,1);
}

//#########################################################################
//simple DDR test
//#########################################################################

#define NO_LOOP_CNT       250
#define DDR_START_ADDR    0x80000000

menuitem "AM335x DDR Tests"

hotmenu DDR_DataTransferCheck()
{
    unsigned int temp_reg_rd = 0;
        unsigned int temp_reg_wr = 0xA5A5A5A5;
        unsigned int i=0;
        unsigned int error=0;
      GEL_TextOut("Try Accessing DDR memory....Write data\n");
        for (i=0;i<NO_LOOP_CNT; i++)
        {
         *((UWORD32 *)DDR_START_ADDR + (i)) = temp_reg_wr;
         //GEL_TextOut("Data Written is :: %x \n",,,,,(unsigned int *)i);
       GEL_TextOut("Data written at :: %x \n",,,,,(unsigned int *)DDR_START_ADDR + (i));

        
        }
      for (i=0;i<NO_LOOP_CNT; i++)
        {

        temp_reg_rd =  *((UWORD32 *)DDR_START_ADDR + (i));
        // GEL_TextOut("Data Read is :: %x \n",,,,,(unsigned int *)temp_reg_rd);
        if(temp_reg_rd != 0xA5A5A5A5)
           {
            //GEL_TextOut("Data check failed at :: %x \n",,,,,(unsigned int *)DDR_START_ADDR + (i));

            error++;    
           }
        else
        {
        //GEL_TextOut("Data check passed  at :: %x \n",,,,,(unsigned int *)DDR_START_ADDR + (i));

         } 
        GEL_TextOut("No of Failed locations  are :: %x \n",,,,,(unsigned int *)error);

        }

        if(error != 0)
        {
        GEL_TextOut("Data Integrity check Failed ");
        }
        else {
        GEL_TextOut("Data Integrity check Passed\n");
        }   
}

//#########################################################################
//EDMA tests for DDR
//#########################################################################

#define TPCC_BASE_ADDR          0x49000000
#define INT_SRAM_BASE_ADDR      0x00300000
#define DDR_BASE_ADDR           0x80000000
#define DMA_SIZE                512 /*Words*/
#define L3_OFFSET_ADDR          0x40000000  
#define CPU_OFFSET_ADDR         0x40000000

#define CM_PER_TPTC0_CLKCTRL (PRCM_BASE_ADDR +0x0024)
#define CM_PER_TPCC_CLKCTRL  (PRCM_BASE_ADDR +0x00BC)
#define CM_PER_TPTC1_CLKCTRL (PRCM_BASE_ADDR +0x00FC)
#define CM_PER_TPTC2_CLKCTRL (PRCM_BASE_ADDR +0x0100)

hotmenu EDMA() 
{
unsigned int pattern=0;
unsigned int queuqePri=0;
unsigned int TPTC0_MMU_MAP=0;
   
	GEL_TextOut("\n\nThis EDMA test consists of 8 tests.\n");
	EdmaPrcm();
    memWrite(DDR_BASE_ADDR, 0x100, 0);
    memWrite(0x40300000,    0x100, 0);
    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 1\n");
    pattern=0xAAAAAAAA;
    queuqePri=0;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 2\n");
    pattern=0x55555555;
    queuqePri=1;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 3\n");
    pattern=0x00FF00FF;
    queuqePri=2;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 4\n");
    pattern=0x80808080;
    queuqePri=3;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 5\n");
    pattern=0xCCCCCCCC;
    queuqePri=4;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 6\n");
    pattern=0xA0A0A0A0;
    queuqePri=5;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 7\n");
    pattern=0x12345678;
    queuqePri=6;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");

    /*DDR ->Internal SRAM EDMA data Transfer */
    GEL_TextOut("\nTest 8\n");
    pattern=0xAA55AA55;
    queuqePri=7;
    memWrite(DDR_BASE_ADDR, DMA_SIZE, pattern);
    edmaConfigure(DDR_BASE_ADDR, (INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR), DMA_SIZE, queuqePri);
    compare((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    /*Internal SRAM->DDR EDMA data Transfer */
    memWrite(((INT_SRAM_BASE_ADDR+CPU_OFFSET_ADDR)+4*DMA_SIZE), DMA_SIZE, pattern);
    edmaConfigure(((INT_SRAM_BASE_ADDR+L3_OFFSET_ADDR)+4*DMA_SIZE), (DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, queuqePri);
    compare((DDR_BASE_ADDR+4*DMA_SIZE), DMA_SIZE, pattern);
    GEL_TextOut("\n");
    GEL_TextOut("Test is complete\n");
}

edmaConfigure(unsigned int srcAddr, unsigned DstAddr, unsigned short dmaSize, unsigned int QUEPRI)
{
  GEL_TextOut("\EDMA Transfer Start for QUEPRI %x\n",,,,,QUEPRI); 
  WR_MEM_32(TPCC_BASE_ADDR +0x0284, (QUEPRI&0x7));
  WR_MEM_32(TPCC_BASE_ADDR +0x0340, 0x00000001);
  WR_MEM_32(TPCC_BASE_ADDR +0x0240, 0x00000000);
  WR_MEM_32(TPCC_BASE_ADDR +0x0100, 0x00000000);
  WR_MEM_32(TPCC_BASE_ADDR +0x4000, 0x00100200);
  WR_MEM_32(TPCC_BASE_ADDR +0x4004, srcAddr);
  WR_MEM_32(TPCC_BASE_ADDR +0x400C, DstAddr);
  WR_MEM_32(TPCC_BASE_ADDR +0x4008, 0x00010000 | (dmaSize * 4)); /* byte len */
  WR_MEM_32(TPCC_BASE_ADDR +0x401C, 0x00000001);
  WR_MEM_32(TPCC_BASE_ADDR +0x4010, 0x00000000);
  WR_MEM_32(TPCC_BASE_ADDR +0x4018, 0x00000000);
  WR_MEM_32(TPCC_BASE_ADDR +0x4014, 0x0000ffff);
  WR_MEM_32(TPCC_BASE_ADDR +0x1060, 0x00000001);
  WR_MEM_32(TPCC_BASE_ADDR +0x1010, 0x00000001);

  while( (RD_MEM_32(TPCC_BASE_ADDR+0x1068)&0x1) !=1 ) {}
  WR_MEM_32(TPCC_BASE_ADDR+0x1070, 0x1); 
  GEL_TextOut("\EDMA Transfer Complete for QUEPRI %x\n",,,,,QUEPRI);    
}

memWrite(unsigned int Addr, unsigned int size, unsigned int initData)
{
unsigned int len=0;
  for(len=0; len<size; len++) {
    WR_MEM_32(Addr+4*len, (initData+len));
  }
  GEL_TextOut("Write is completed Starting @%x\n",,,,,Addr);    
}

compare(unsigned int Addr, unsigned int size, unsigned int initData)
{
  unsigned int len=0, fail=0;
  for(len=0; len<size; len++) {
     if( RD_MEM_32(Addr+4*len) != (initData+len) ) {
       GEL_TextOut("\nFailed@%x\tExpected=%x \tRead=%x\n",,,,,(Addr+4*len),(initData+len),RD_MEM_32(Addr+4*len) );
       fail++;
       } 
     }
  if(fail==0) {
    GEL_TextOut("Test Case Passed for Destination Addr=%x\n",,,,,Addr); 
    }
}

EdmaPrcm() {
   WR_MEM_32(CM_PER_TPCC_CLKCTRL, 2); // it was L3
   WR_MEM_32(CM_PER_TPTC0_CLKCTRL ,   2); 
   WR_MEM_32(CM_PER_TPTC1_CLKCTRL ,   2);
   WR_MEM_32(CM_PER_TPTC2_CLKCTRL ,   2);
}

//##############################################################################
//##############################################################################
//                       SYS_CLKOUT2 Configuration Section
//##############################################################################
//##############################################################################

menuitem "SYS_CLKOUT2"

hotmenu OSC_32KHz()
{
set_CLKOUT2(0);
} 

hotmenu L3_CLK()
{
set_CLKOUT2(1);
} 

//DDR needs to be enabled
hotmenu DDR_PHY_Clock()
{
EMIF_PRCM_CLK_ENABLE();
set_CLKOUT2(2);
} 

hotmenu PER_Clock()
{
set_CLKOUT2(3);
} 

hotmenu LCD_Clock()
{
set_CLKOUT2(4);
} 


set_CLKOUT2(UWORD32 mode)
{
unsigned int temp;
unsigned int divider = 2; //change here if you want to pick a different divider

WR_MEM_32(CONF_XDMA_EVENT_INTR1,0x3); // Set Pinmux to mode 3 (and rest to zero)
WR_MEM_32(CM_CLKOUT_CTRL, (divider-1) << 3); //Set divider (which is set above)

temp = RD_MEM_32(CM_CLKOUT_CTRL);
temp = (temp & ~(0x7) ) | mode;
WR_MEM_32(CM_CLKOUT_CTRL,temp);

enable_SYS_CLKOUT2();

if(mode == 0)
    GEL_TextOut(" **** SYS_CLKOUT2 = 32khz Crystal (divided by %d)\n",,,,,(unsigned int *)(divider));
else if (mode == 1)
    GEL_TextOut(" **** SYS_CLKOUT2 = L3 (From Core PLL) (divided by %d)\n",,,,,(unsigned int *)(divider));
else if (mode == 2)
    GEL_TextOut(" **** SYS_CLKOUT2 = DDR PHY CLK (divided by %d)\n",,,,,(unsigned int *)(divider));
else if (mode == 3)
    GEL_TextOut(" **** SYS_CLKOUT2 = Per PLL Clock (192 Mhz)(divided by %d)\n",,,,,(unsigned int *)(divider));
else
    GEL_TextOut(" **** SYS_CLKOUT2 = LCD Pixel Clock (divided by %d)\n",,,,,(unsigned int *)(divider));
}

enable_SYS_CLKOUT2()
{
unsigned int temp;
temp = RD_MEM_32(CM_CLKOUT_CTRL);
temp = temp | 0x80;
WR_MEM_32(CM_CLKOUT_CTRL,temp);
}


menuitem "Status"

hotmenu Device_Type()
{
unsigned int temp;
temp = RD_MEM_32(CONTROL_STATUS);
temp = (temp & 0x700) >> 8;
if (temp == 0)
  GEL_TextOut(" **** Device Type: Test\n","Output",1,1,1);
else if (temp == 1)
  GEL_TextOut(" **** Device Type: EMU\n","Output",1,1,1);
else if (temp == 2)
  GEL_TextOut(" **** Device Type: HS\n","Output",1,1,1);
else if (temp == 3)
  GEL_TextOut(" **** Device Type: GP\n","Output",1,1,1);
else 
  GEL_TextOut(" **** Device Type: INVALID\n","Output",1,1,1);
}
